"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ofetch";
exports.ids = ["vendor-chunks/ofetch"];
exports.modules = {

/***/ "(ssr)/./node_modules/ofetch/dist/node.mjs":
/*!*******************************************!*\
  !*** ./node_modules/ofetch/dist/node.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $fetch: () => (/* binding */ $fetch),\n/* harmony export */   AbortController: () => (/* binding */ AbortController),\n/* harmony export */   FetchError: () => (/* reexport safe */ _shared_ofetch_03887fc3_mjs__WEBPACK_IMPORTED_MODULE_3__.F),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   createFetch: () => (/* reexport safe */ _shared_ofetch_03887fc3_mjs__WEBPACK_IMPORTED_MODULE_3__.c),\n/* harmony export */   createFetchError: () => (/* reexport safe */ _shared_ofetch_03887fc3_mjs__WEBPACK_IMPORTED_MODULE_3__.a),\n/* harmony export */   createNodeFetch: () => (/* binding */ createNodeFetch),\n/* harmony export */   fetch: () => (/* binding */ fetch),\n/* harmony export */   ofetch: () => (/* binding */ ofetch)\n/* harmony export */ });\n/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:http */ \"node:http\");\n/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:https */ \"node:https\");\n/* harmony import */ var node_fetch_native__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-fetch-native */ \"(ssr)/./node_modules/node-fetch-native/dist/index.mjs\");\n/* harmony import */ var _shared_ofetch_03887fc3_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/ofetch.03887fc3.mjs */ \"(ssr)/./node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs\");\n/* harmony import */ var destr__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! destr */ \"(ssr)/./node_modules/destr/dist/index.mjs\");\n\n\n\n\n\n\n\n\nfunction createNodeFetch() {\n  const useKeepAlive = JSON.parse(process.env.FETCH_KEEP_ALIVE || \"false\");\n  if (!useKeepAlive) {\n    return node_fetch_native__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n  }\n  const agentOptions = { keepAlive: true };\n  const httpAgent = new node_http__WEBPACK_IMPORTED_MODULE_0__.Agent(agentOptions);\n  const httpsAgent = new node_https__WEBPACK_IMPORTED_MODULE_1__.Agent(agentOptions);\n  const nodeFetchOptions = {\n    agent(parsedURL) {\n      return parsedURL.protocol === \"http:\" ? httpAgent : httpsAgent;\n    }\n  };\n  return function nodeFetchWithKeepAlive(input, init) {\n    return (0,node_fetch_native__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(input, { ...nodeFetchOptions, ...init });\n  };\n}\nconst fetch = globalThis.fetch ? (...args) => globalThis.fetch(...args) : createNodeFetch();\nconst Headers = globalThis.Headers || node_fetch_native__WEBPACK_IMPORTED_MODULE_2__.Headers;\nconst AbortController = globalThis.AbortController || node_fetch_native__WEBPACK_IMPORTED_MODULE_2__.AbortController;\nconst ofetch = (0,_shared_ofetch_03887fc3_mjs__WEBPACK_IMPORTED_MODULE_3__.c)({ fetch, Headers, AbortController });\nconst $fetch = ofetch;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2ZldGNoL2Rpc3Qvbm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkI7QUFDRTtBQUMyRTtBQUMxQztBQUNzQjtBQUN2RTtBQUNGOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcseURBQVM7QUFDcEI7QUFDQSx5QkFBeUI7QUFDekIsd0JBQXdCLDRDQUFVO0FBQ2xDLHlCQUF5Qiw2Q0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFTLFVBQVUsOEJBQThCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzREFBUztBQUMvQyxzREFBc0QsOERBQWlCO0FBQ3ZFLGVBQWUsOERBQVcsR0FBRyxpQ0FBaUM7QUFDOUQ7O0FBRXlGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlZGljdGEtZGFwcC8uL25vZGVfbW9kdWxlcy9vZmV0Y2gvZGlzdC9ub2RlLm1qcz81N2ZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBodHRwIGZyb20gJ25vZGU6aHR0cCc7XG5pbXBvcnQgaHR0cHMgZnJvbSAnbm9kZTpodHRwcyc7XG5pbXBvcnQgbm9kZUZldGNoLCB7IEhlYWRlcnMgYXMgSGVhZGVycyQxLCBBYm9ydENvbnRyb2xsZXIgYXMgQWJvcnRDb250cm9sbGVyJDEgfSBmcm9tICdub2RlLWZldGNoLW5hdGl2ZSc7XG5pbXBvcnQgeyBjIGFzIGNyZWF0ZUZldGNoIH0gZnJvbSAnLi9zaGFyZWQvb2ZldGNoLjAzODg3ZmMzLm1qcyc7XG5leHBvcnQgeyBGIGFzIEZldGNoRXJyb3IsIGEgYXMgY3JlYXRlRmV0Y2hFcnJvciB9IGZyb20gJy4vc2hhcmVkL29mZXRjaC4wMzg4N2ZjMy5tanMnO1xuaW1wb3J0ICdkZXN0cic7XG5pbXBvcnQgJ3Vmbyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVGZXRjaCgpIHtcbiAgY29uc3QgdXNlS2VlcEFsaXZlID0gSlNPTi5wYXJzZShwcm9jZXNzLmVudi5GRVRDSF9LRUVQX0FMSVZFIHx8IFwiZmFsc2VcIik7XG4gIGlmICghdXNlS2VlcEFsaXZlKSB7XG4gICAgcmV0dXJuIG5vZGVGZXRjaDtcbiAgfVxuICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7IGtlZXBBbGl2ZTogdHJ1ZSB9O1xuICBjb25zdCBodHRwQWdlbnQgPSBuZXcgaHR0cC5BZ2VudChhZ2VudE9wdGlvbnMpO1xuICBjb25zdCBodHRwc0FnZW50ID0gbmV3IGh0dHBzLkFnZW50KGFnZW50T3B0aW9ucyk7XG4gIGNvbnN0IG5vZGVGZXRjaE9wdGlvbnMgPSB7XG4gICAgYWdlbnQocGFyc2VkVVJMKSB7XG4gICAgICByZXR1cm4gcGFyc2VkVVJMLnByb3RvY29sID09PSBcImh0dHA6XCIgPyBodHRwQWdlbnQgOiBodHRwc0FnZW50O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vZGVGZXRjaFdpdGhLZWVwQWxpdmUoaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbm9kZUZldGNoKGlucHV0LCB7IC4uLm5vZGVGZXRjaE9wdGlvbnMsIC4uLmluaXQgfSk7XG4gIH07XG59XG5jb25zdCBmZXRjaCA9IGdsb2JhbFRoaXMuZmV0Y2ggPyAoLi4uYXJncykgPT4gZ2xvYmFsVGhpcy5mZXRjaCguLi5hcmdzKSA6IGNyZWF0ZU5vZGVGZXRjaCgpO1xuY29uc3QgSGVhZGVycyA9IGdsb2JhbFRoaXMuSGVhZGVycyB8fCBIZWFkZXJzJDE7XG5jb25zdCBBYm9ydENvbnRyb2xsZXIgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlciB8fCBBYm9ydENvbnRyb2xsZXIkMTtcbmNvbnN0IG9mZXRjaCA9IGNyZWF0ZUZldGNoKHsgZmV0Y2gsIEhlYWRlcnMsIEFib3J0Q29udHJvbGxlciB9KTtcbmNvbnN0ICRmZXRjaCA9IG9mZXRjaDtcblxuZXhwb3J0IHsgJGZldGNoLCBBYm9ydENvbnRyb2xsZXIsIEhlYWRlcnMsIGNyZWF0ZUZldGNoLCBjcmVhdGVOb2RlRmV0Y2gsIGZldGNoLCBvZmV0Y2ggfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ofetch/dist/node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   F: () => (/* binding */ FetchError),\n/* harmony export */   a: () => (/* binding */ createFetchError),\n/* harmony export */   c: () => (/* binding */ createFetch)\n/* harmony export */ });\n/* harmony import */ var destr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! destr */ \"(ssr)/./node_modules/destr/dist/index.mjs\");\n/* harmony import */ var ufo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ufo */ \"(ssr)/./node_modules/ufo/dist/index.mjs\");\n\n\n\nclass FetchError extends Error {\n  constructor(message, opts) {\n    super(message, opts);\n    this.name = \"FetchError\";\n    if (opts?.cause && !this.cause) {\n      this.cause = opts.cause;\n    }\n  }\n}\nfunction createFetchError(ctx) {\n  const errorMessage = ctx.error?.message || ctx.error?.toString() || \"\";\n  const method = ctx.request?.method || ctx.options?.method || \"GET\";\n  const url = ctx.request?.url || String(ctx.request) || \"/\";\n  const requestStr = `[${method}] ${JSON.stringify(url)}`;\n  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : \"<no response>\";\n  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : \"\"}`;\n  const fetchError = new FetchError(\n    message,\n    ctx.error ? { cause: ctx.error } : void 0\n  );\n  for (const key of [\"request\", \"options\", \"response\"]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx[key];\n      }\n    });\n  }\n  for (const [key, refKey] of [\n    [\"data\", \"_data\"],\n    [\"status\", \"status\"],\n    [\"statusCode\", \"status\"],\n    [\"statusText\", \"statusText\"],\n    [\"statusMessage\", \"statusText\"]\n  ]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx.response && ctx.response[refKey];\n      }\n    });\n  }\n  return fetchError;\n}\n\nconst payloadMethods = new Set(\n  Object.freeze([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"])\n);\nfunction isPayloadMethod(method = \"GET\") {\n  return payloadMethods.has(method.toUpperCase());\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nconst textTypes = /* @__PURE__ */ new Set([\n  \"image/svg\",\n  \"application/xml\",\n  \"application/xhtml\",\n  \"application/html\"\n]);\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(_contentType = \"\") {\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\nfunction resolveFetchOptions(request, input, defaults, Headers) {\n  const headers = mergeHeaders(\n    input?.headers ?? request?.headers,\n    defaults?.headers,\n    Headers\n  );\n  let query;\n  if (defaults?.query || defaults?.params || input?.params || input?.query) {\n    query = {\n      ...defaults?.params,\n      ...defaults?.query,\n      ...input?.params,\n      ...input?.query\n    };\n  }\n  return {\n    ...defaults,\n    ...input,\n    query,\n    params: query,\n    headers\n  };\n}\nfunction mergeHeaders(input, defaults, Headers) {\n  if (!defaults) {\n    return new Headers(input);\n  }\n  const headers = new Headers(defaults);\n  if (input) {\n    for (const [key, value] of Symbol.iterator in input || Array.isArray(input) ? input : new Headers(input)) {\n      headers.set(key, value);\n    }\n  }\n  return headers;\n}\nasync function callHooks(context, hooks) {\n  if (hooks) {\n    if (Array.isArray(hooks)) {\n      for (const hook of hooks) {\n        await hook(context);\n      }\n    } else {\n      await hooks(context);\n    }\n  }\n}\n\nconst retryStatusCodes = /* @__PURE__ */ new Set([\n  408,\n  // Request Timeout\n  409,\n  // Conflict\n  425,\n  // Too Early (Experimental)\n  429,\n  // Too Many Requests\n  500,\n  // Internal Server Error\n  502,\n  // Bad Gateway\n  503,\n  // Service Unavailable\n  504\n  // Gateway Timeout\n]);\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\nfunction createFetch(globalOptions = {}) {\n  const {\n    fetch = globalThis.fetch,\n    Headers = globalThis.Headers,\n    AbortController = globalThis.AbortController\n  } = globalOptions;\n  async function onError(context) {\n    const isAbort = context.error && context.error.name === \"AbortError\" && !context.options.timeout || false;\n    if (context.options.retry !== false && !isAbort) {\n      let retries;\n      if (typeof context.options.retry === \"number\") {\n        retries = context.options.retry;\n      } else {\n        retries = isPayloadMethod(context.options.method) ? 0 : 1;\n      }\n      const responseCode = context.response && context.response.status || 500;\n      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {\n        const retryDelay = typeof context.options.retryDelay === \"function\" ? context.options.retryDelay(context) : context.options.retryDelay || 0;\n        if (retryDelay > 0) {\n          await new Promise((resolve) => setTimeout(resolve, retryDelay));\n        }\n        return $fetchRaw(context.request, {\n          ...context.options,\n          retry: retries - 1\n        });\n      }\n    }\n    const error = createFetchError(context);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(error, $fetchRaw);\n    }\n    throw error;\n  }\n  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {\n    const context = {\n      request: _request,\n      options: resolveFetchOptions(\n        _request,\n        _options,\n        globalOptions.defaults,\n        Headers\n      ),\n      response: void 0,\n      error: void 0\n    };\n    if (context.options.method) {\n      context.options.method = context.options.method.toUpperCase();\n    }\n    if (context.options.onRequest) {\n      await callHooks(context, context.options.onRequest);\n    }\n    if (typeof context.request === \"string\") {\n      if (context.options.baseURL) {\n        context.request = (0,ufo__WEBPACK_IMPORTED_MODULE_1__.withBase)(context.request, context.options.baseURL);\n      }\n      if (context.options.query) {\n        context.request = (0,ufo__WEBPACK_IMPORTED_MODULE_1__.withQuery)(context.request, context.options.query);\n        delete context.options.query;\n      }\n      if (\"query\" in context.options) {\n        delete context.options.query;\n      }\n      if (\"params\" in context.options) {\n        delete context.options.params;\n      }\n    }\n    if (context.options.body && isPayloadMethod(context.options.method)) {\n      if (isJSONSerializable(context.options.body)) {\n        context.options.body = typeof context.options.body === \"string\" ? context.options.body : JSON.stringify(context.options.body);\n        context.options.headers = new Headers(context.options.headers || {});\n        if (!context.options.headers.has(\"content-type\")) {\n          context.options.headers.set(\"content-type\", \"application/json\");\n        }\n        if (!context.options.headers.has(\"accept\")) {\n          context.options.headers.set(\"accept\", \"application/json\");\n        }\n      } else if (\n        // ReadableStream Body\n        \"pipeTo\" in context.options.body && typeof context.options.body.pipeTo === \"function\" || // Node.js Stream Body\n        typeof context.options.body.pipe === \"function\"\n      ) {\n        if (!(\"duplex\" in context.options)) {\n          context.options.duplex = \"half\";\n        }\n      }\n    }\n    let abortTimeout;\n    if (!context.options.signal && context.options.timeout) {\n      const controller = new AbortController();\n      abortTimeout = setTimeout(() => {\n        const error = new Error(\n          \"[TimeoutError]: The operation was aborted due to timeout\"\n        );\n        error.name = \"TimeoutError\";\n        error.code = 23;\n        controller.abort(error);\n      }, context.options.timeout);\n      context.options.signal = controller.signal;\n    }\n    try {\n      context.response = await fetch(\n        context.request,\n        context.options\n      );\n    } catch (error) {\n      context.error = error;\n      if (context.options.onRequestError) {\n        await callHooks(\n          context,\n          context.options.onRequestError\n        );\n      }\n      return await onError(context);\n    } finally {\n      if (abortTimeout) {\n        clearTimeout(abortTimeout);\n      }\n    }\n    const hasBody = (context.response.body || // https://github.com/unjs/ofetch/issues/324\n    // https://github.com/unjs/ofetch/issues/294\n    // https://github.com/JakeChampion/fetch/issues/1454\n    context.response._bodyInit) && !nullBodyResponses.has(context.response.status) && context.options.method !== \"HEAD\";\n    if (hasBody) {\n      const responseType = (context.options.parseResponse ? \"json\" : context.options.responseType) || detectResponseType(context.response.headers.get(\"content-type\") || \"\");\n      switch (responseType) {\n        case \"json\": {\n          const data = await context.response.text();\n          const parseFunction = context.options.parseResponse || destr__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n          context.response._data = parseFunction(data);\n          break;\n        }\n        case \"stream\": {\n          context.response._data = context.response.body || context.response._bodyInit;\n          break;\n        }\n        default: {\n          context.response._data = await context.response[responseType]();\n        }\n      }\n    }\n    if (context.options.onResponse) {\n      await callHooks(\n        context,\n        context.options.onResponse\n      );\n    }\n    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {\n      if (context.options.onResponseError) {\n        await callHooks(\n          context,\n          context.options.onResponseError\n        );\n      }\n      return await onError(context);\n    }\n    return context.response;\n  };\n  const $fetch = async function $fetch2(request, options) {\n    const r = await $fetchRaw(request, options);\n    return r._data;\n  };\n  $fetch.raw = $fetchRaw;\n  $fetch.native = (...args) => fetch(...args);\n  $fetch.create = (defaultOptions = {}, customGlobalOptions = {}) => createFetch({\n    ...globalOptions,\n    ...customGlobalOptions,\n    defaults: {\n      ...globalOptions.defaults,\n      ...customGlobalOptions.defaults,\n      ...defaultOptions\n    }\n  });\n  return $fetch;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2ZldGNoL2Rpc3Qvc2hhcmVkL29mZXRjaC4wMzg4N2ZjMy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEI7QUFDZ0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sSUFBSSxvQkFBb0I7QUFDeEQsc0NBQXNDLHFCQUFxQixFQUFFLHdCQUF3QjtBQUNyRixxQkFBcUIsV0FBVyxJQUFJLFVBQVUsRUFBRSxtQkFBbUIsYUFBYSxPQUFPO0FBQ3ZGO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQVE7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNkNBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFb0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVkaWN0YS1kYXBwLy4vbm9kZV9tb2R1bGVzL29mZXRjaC9kaXN0L3NoYXJlZC9vZmV0Y2guMDM4ODdmYzMubWpzPzE1NTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlc3RyIGZyb20gJ2Rlc3RyJztcbmltcG9ydCB7IHdpdGhCYXNlLCB3aXRoUXVlcnkgfSBmcm9tICd1Zm8nO1xuXG5jbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRzKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgb3B0cyk7XG4gICAgdGhpcy5uYW1lID0gXCJGZXRjaEVycm9yXCI7XG4gICAgaWYgKG9wdHM/LmNhdXNlICYmICF0aGlzLmNhdXNlKSB7XG4gICAgICB0aGlzLmNhdXNlID0gb3B0cy5jYXVzZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoRXJyb3IoY3R4KSB7XG4gIGNvbnN0IGVycm9yTWVzc2FnZSA9IGN0eC5lcnJvcj8ubWVzc2FnZSB8fCBjdHguZXJyb3I/LnRvU3RyaW5nKCkgfHwgXCJcIjtcbiAgY29uc3QgbWV0aG9kID0gY3R4LnJlcXVlc3Q/Lm1ldGhvZCB8fCBjdHgub3B0aW9ucz8ubWV0aG9kIHx8IFwiR0VUXCI7XG4gIGNvbnN0IHVybCA9IGN0eC5yZXF1ZXN0Py51cmwgfHwgU3RyaW5nKGN0eC5yZXF1ZXN0KSB8fCBcIi9cIjtcbiAgY29uc3QgcmVxdWVzdFN0ciA9IGBbJHttZXRob2R9XSAke0pTT04uc3RyaW5naWZ5KHVybCl9YDtcbiAgY29uc3Qgc3RhdHVzU3RyID0gY3R4LnJlc3BvbnNlID8gYCR7Y3R4LnJlc3BvbnNlLnN0YXR1c30gJHtjdHgucmVzcG9uc2Uuc3RhdHVzVGV4dH1gIDogXCI8bm8gcmVzcG9uc2U+XCI7XG4gIGNvbnN0IG1lc3NhZ2UgPSBgJHtyZXF1ZXN0U3RyfTogJHtzdGF0dXNTdHJ9JHtlcnJvck1lc3NhZ2UgPyBgICR7ZXJyb3JNZXNzYWdlfWAgOiBcIlwifWA7XG4gIGNvbnN0IGZldGNoRXJyb3IgPSBuZXcgRmV0Y2hFcnJvcihcbiAgICBtZXNzYWdlLFxuICAgIGN0eC5lcnJvciA/IHsgY2F1c2U6IGN0eC5lcnJvciB9IDogdm9pZCAwXG4gICk7XG4gIGZvciAoY29uc3Qga2V5IG9mIFtcInJlcXVlc3RcIiwgXCJvcHRpb25zXCIsIFwicmVzcG9uc2VcIl0pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmV0Y2hFcnJvciwga2V5LCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHJlZktleV0gb2YgW1xuICAgIFtcImRhdGFcIiwgXCJfZGF0YVwiXSxcbiAgICBbXCJzdGF0dXNcIiwgXCJzdGF0dXNcIl0sXG4gICAgW1wic3RhdHVzQ29kZVwiLCBcInN0YXR1c1wiXSxcbiAgICBbXCJzdGF0dXNUZXh0XCIsIFwic3RhdHVzVGV4dFwiXSxcbiAgICBbXCJzdGF0dXNNZXNzYWdlXCIsIFwic3RhdHVzVGV4dFwiXVxuICBdKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZldGNoRXJyb3IsIGtleSwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gY3R4LnJlc3BvbnNlICYmIGN0eC5yZXNwb25zZVtyZWZLZXldO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBmZXRjaEVycm9yO1xufVxuXG5jb25zdCBwYXlsb2FkTWV0aG9kcyA9IG5ldyBTZXQoXG4gIE9iamVjdC5mcmVlemUoW1wiUEFUQ0hcIiwgXCJQT1NUXCIsIFwiUFVUXCIsIFwiREVMRVRFXCJdKVxuKTtcbmZ1bmN0aW9uIGlzUGF5bG9hZE1ldGhvZChtZXRob2QgPSBcIkdFVFwiKSB7XG4gIHJldHVybiBwYXlsb2FkTWV0aG9kcy5oYXMobWV0aG9kLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gaXNKU09OU2VyaWFsaXphYmxlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0ID09PSBcInN0cmluZ1wiIHx8IHQgPT09IFwibnVtYmVyXCIgfHwgdCA9PT0gXCJib29sZWFuXCIgfHwgdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZS5idWZmZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiO1xufVxuY29uc3QgdGV4dFR5cGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImltYWdlL3N2Z1wiLFxuICBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcImFwcGxpY2F0aW9uL3hodG1sXCIsXG4gIFwiYXBwbGljYXRpb24vaHRtbFwiXG5dKTtcbmNvbnN0IEpTT05fUkUgPSAvXmFwcGxpY2F0aW9uXFwvKD86W1xcdyEjJCUmKi5eYH4tXSpcXCspP2pzb24oOy4rKT8kL2k7XG5mdW5jdGlvbiBkZXRlY3RSZXNwb25zZVR5cGUoX2NvbnRlbnRUeXBlID0gXCJcIikge1xuICBpZiAoIV9jb250ZW50VHlwZSkge1xuICAgIHJldHVybiBcImpzb25cIjtcbiAgfVxuICBjb25zdCBjb250ZW50VHlwZSA9IF9jb250ZW50VHlwZS5zcGxpdChcIjtcIikuc2hpZnQoKSB8fCBcIlwiO1xuICBpZiAoSlNPTl9SRS50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgIHJldHVybiBcImpzb25cIjtcbiAgfVxuICBpZiAodGV4dFR5cGVzLmhhcyhjb250ZW50VHlwZSkgfHwgY29udGVudFR5cGUuc3RhcnRzV2l0aChcInRleHQvXCIpKSB7XG4gICAgcmV0dXJuIFwidGV4dFwiO1xuICB9XG4gIHJldHVybiBcImJsb2JcIjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVGZXRjaE9wdGlvbnMocmVxdWVzdCwgaW5wdXQsIGRlZmF1bHRzLCBIZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBtZXJnZUhlYWRlcnMoXG4gICAgaW5wdXQ/LmhlYWRlcnMgPz8gcmVxdWVzdD8uaGVhZGVycyxcbiAgICBkZWZhdWx0cz8uaGVhZGVycyxcbiAgICBIZWFkZXJzXG4gICk7XG4gIGxldCBxdWVyeTtcbiAgaWYgKGRlZmF1bHRzPy5xdWVyeSB8fCBkZWZhdWx0cz8ucGFyYW1zIHx8IGlucHV0Py5wYXJhbXMgfHwgaW5wdXQ/LnF1ZXJ5KSB7XG4gICAgcXVlcnkgPSB7XG4gICAgICAuLi5kZWZhdWx0cz8ucGFyYW1zLFxuICAgICAgLi4uZGVmYXVsdHM/LnF1ZXJ5LFxuICAgICAgLi4uaW5wdXQ/LnBhcmFtcyxcbiAgICAgIC4uLmlucHV0Py5xdWVyeVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kZWZhdWx0cyxcbiAgICAuLi5pbnB1dCxcbiAgICBxdWVyeSxcbiAgICBwYXJhbXM6IHF1ZXJ5LFxuICAgIGhlYWRlcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlSGVhZGVycyhpbnB1dCwgZGVmYXVsdHMsIEhlYWRlcnMpIHtcbiAgaWYgKCFkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgSGVhZGVycyhpbnB1dCk7XG4gIH1cbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGRlZmF1bHRzKTtcbiAgaWYgKGlucHV0KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgU3ltYm9sLml0ZXJhdG9yIGluIGlucHV0IHx8IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBuZXcgSGVhZGVycyhpbnB1dCkpIHtcbiAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxIb29rcyhjb250ZXh0LCBob29rcykge1xuICBpZiAoaG9va3MpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShob29rcykpIHtcbiAgICAgIGZvciAoY29uc3QgaG9vayBvZiBob29rcykge1xuICAgICAgICBhd2FpdCBob29rKGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBob29rcyhjb250ZXh0KTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmV0cnlTdGF0dXNDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgNDA4LFxuICAvLyBSZXF1ZXN0IFRpbWVvdXRcbiAgNDA5LFxuICAvLyBDb25mbGljdFxuICA0MjUsXG4gIC8vIFRvbyBFYXJseSAoRXhwZXJpbWVudGFsKVxuICA0MjksXG4gIC8vIFRvbyBNYW55IFJlcXVlc3RzXG4gIDUwMCxcbiAgLy8gSW50ZXJuYWwgU2VydmVyIEVycm9yXG4gIDUwMixcbiAgLy8gQmFkIEdhdGV3YXlcbiAgNTAzLFxuICAvLyBTZXJ2aWNlIFVuYXZhaWxhYmxlXG4gIDUwNFxuICAvLyBHYXRld2F5IFRpbWVvdXRcbl0pO1xuY29uc3QgbnVsbEJvZHlSZXNwb25zZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbMTAxLCAyMDQsIDIwNSwgMzA0XSk7XG5mdW5jdGlvbiBjcmVhdGVGZXRjaChnbG9iYWxPcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaCxcbiAgICBIZWFkZXJzID0gZ2xvYmFsVGhpcy5IZWFkZXJzLFxuICAgIEFib3J0Q29udHJvbGxlciA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyXG4gIH0gPSBnbG9iYWxPcHRpb25zO1xuICBhc3luYyBmdW5jdGlvbiBvbkVycm9yKGNvbnRleHQpIHtcbiAgICBjb25zdCBpc0Fib3J0ID0gY29udGV4dC5lcnJvciAmJiBjb250ZXh0LmVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiICYmICFjb250ZXh0Lm9wdGlvbnMudGltZW91dCB8fCBmYWxzZTtcbiAgICBpZiAoY29udGV4dC5vcHRpb25zLnJldHJ5ICE9PSBmYWxzZSAmJiAhaXNBYm9ydCkge1xuICAgICAgbGV0IHJldHJpZXM7XG4gICAgICBpZiAodHlwZW9mIGNvbnRleHQub3B0aW9ucy5yZXRyeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXRyaWVzID0gY29udGV4dC5vcHRpb25zLnJldHJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0cmllcyA9IGlzUGF5bG9hZE1ldGhvZChjb250ZXh0Lm9wdGlvbnMubWV0aG9kKSA/IDAgOiAxO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2VDb2RlID0gY29udGV4dC5yZXNwb25zZSAmJiBjb250ZXh0LnJlc3BvbnNlLnN0YXR1cyB8fCA1MDA7XG4gICAgICBpZiAocmV0cmllcyA+IDAgJiYgKEFycmF5LmlzQXJyYXkoY29udGV4dC5vcHRpb25zLnJldHJ5U3RhdHVzQ29kZXMpID8gY29udGV4dC5vcHRpb25zLnJldHJ5U3RhdHVzQ29kZXMuaW5jbHVkZXMocmVzcG9uc2VDb2RlKSA6IHJldHJ5U3RhdHVzQ29kZXMuaGFzKHJlc3BvbnNlQ29kZSkpKSB7XG4gICAgICAgIGNvbnN0IHJldHJ5RGVsYXkgPSB0eXBlb2YgY29udGV4dC5vcHRpb25zLnJldHJ5RGVsYXkgPT09IFwiZnVuY3Rpb25cIiA/IGNvbnRleHQub3B0aW9ucy5yZXRyeURlbGF5KGNvbnRleHQpIDogY29udGV4dC5vcHRpb25zLnJldHJ5RGVsYXkgfHwgMDtcbiAgICAgICAgaWYgKHJldHJ5RGVsYXkgPiAwKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkZmV0Y2hSYXcoY29udGV4dC5yZXF1ZXN0LCB7XG4gICAgICAgICAgLi4uY29udGV4dC5vcHRpb25zLFxuICAgICAgICAgIHJldHJ5OiByZXRyaWVzIC0gMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBjcmVhdGVGZXRjaEVycm9yKGNvbnRleHQpO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsICRmZXRjaFJhdyk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGNvbnN0ICRmZXRjaFJhdyA9IGFzeW5jIGZ1bmN0aW9uICRmZXRjaFJhdzIoX3JlcXVlc3QsIF9vcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgcmVxdWVzdDogX3JlcXVlc3QsXG4gICAgICBvcHRpb25zOiByZXNvbHZlRmV0Y2hPcHRpb25zKFxuICAgICAgICBfcmVxdWVzdCxcbiAgICAgICAgX29wdGlvbnMsXG4gICAgICAgIGdsb2JhbE9wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAgIEhlYWRlcnNcbiAgICAgICksXG4gICAgICByZXNwb25zZTogdm9pZCAwLFxuICAgICAgZXJyb3I6IHZvaWQgMFxuICAgIH07XG4gICAgaWYgKGNvbnRleHQub3B0aW9ucy5tZXRob2QpIHtcbiAgICAgIGNvbnRleHQub3B0aW9ucy5tZXRob2QgPSBjb250ZXh0Lm9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMub25SZXF1ZXN0KSB7XG4gICAgICBhd2FpdCBjYWxsSG9va3MoY29udGV4dCwgY29udGV4dC5vcHRpb25zLm9uUmVxdWVzdCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29udGV4dC5yZXF1ZXN0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoY29udGV4dC5vcHRpb25zLmJhc2VVUkwpIHtcbiAgICAgICAgY29udGV4dC5yZXF1ZXN0ID0gd2l0aEJhc2UoY29udGV4dC5yZXF1ZXN0LCBjb250ZXh0Lm9wdGlvbnMuYmFzZVVSTCk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dC5vcHRpb25zLnF1ZXJ5KSB7XG4gICAgICAgIGNvbnRleHQucmVxdWVzdCA9IHdpdGhRdWVyeShjb250ZXh0LnJlcXVlc3QsIGNvbnRleHQub3B0aW9ucy5xdWVyeSk7XG4gICAgICAgIGRlbGV0ZSBjb250ZXh0Lm9wdGlvbnMucXVlcnk7XG4gICAgICB9XG4gICAgICBpZiAoXCJxdWVyeVwiIGluIGNvbnRleHQub3B0aW9ucykge1xuICAgICAgICBkZWxldGUgY29udGV4dC5vcHRpb25zLnF1ZXJ5O1xuICAgICAgfVxuICAgICAgaWYgKFwicGFyYW1zXCIgaW4gY29udGV4dC5vcHRpb25zKSB7XG4gICAgICAgIGRlbGV0ZSBjb250ZXh0Lm9wdGlvbnMucGFyYW1zO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmJvZHkgJiYgaXNQYXlsb2FkTWV0aG9kKGNvbnRleHQub3B0aW9ucy5tZXRob2QpKSB7XG4gICAgICBpZiAoaXNKU09OU2VyaWFsaXphYmxlKGNvbnRleHQub3B0aW9ucy5ib2R5KSkge1xuICAgICAgICBjb250ZXh0Lm9wdGlvbnMuYm9keSA9IHR5cGVvZiBjb250ZXh0Lm9wdGlvbnMuYm9keSA9PT0gXCJzdHJpbmdcIiA/IGNvbnRleHQub3B0aW9ucy5ib2R5IDogSlNPTi5zdHJpbmdpZnkoY29udGV4dC5vcHRpb25zLmJvZHkpO1xuICAgICAgICBjb250ZXh0Lm9wdGlvbnMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGNvbnRleHQub3B0aW9ucy5oZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgaWYgKCFjb250ZXh0Lm9wdGlvbnMuaGVhZGVycy5oYXMoXCJjb250ZW50LXR5cGVcIikpIHtcbiAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuaGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGV4dC5vcHRpb25zLmhlYWRlcnMuaGFzKFwiYWNjZXB0XCIpKSB7XG4gICAgICAgICAgY29udGV4dC5vcHRpb25zLmhlYWRlcnMuc2V0KFwiYWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgLy8gUmVhZGFibGVTdHJlYW0gQm9keVxuICAgICAgICBcInBpcGVUb1wiIGluIGNvbnRleHQub3B0aW9ucy5ib2R5ICYmIHR5cGVvZiBjb250ZXh0Lm9wdGlvbnMuYm9keS5waXBlVG8gPT09IFwiZnVuY3Rpb25cIiB8fCAvLyBOb2RlLmpzIFN0cmVhbSBCb2R5XG4gICAgICAgIHR5cGVvZiBjb250ZXh0Lm9wdGlvbnMuYm9keS5waXBlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICkge1xuICAgICAgICBpZiAoIShcImR1cGxleFwiIGluIGNvbnRleHQub3B0aW9ucykpIHtcbiAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZHVwbGV4ID0gXCJoYWxmXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGFib3J0VGltZW91dDtcbiAgICBpZiAoIWNvbnRleHQub3B0aW9ucy5zaWduYWwgJiYgY29udGV4dC5vcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBhYm9ydFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJbVGltZW91dEVycm9yXTogVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCBkdWUgdG8gdGltZW91dFwiXG4gICAgICAgICk7XG4gICAgICAgIGVycm9yLm5hbWUgPSBcIlRpbWVvdXRFcnJvclwiO1xuICAgICAgICBlcnJvci5jb2RlID0gMjM7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoZXJyb3IpO1xuICAgICAgfSwgY29udGV4dC5vcHRpb25zLnRpbWVvdXQpO1xuICAgICAgY29udGV4dC5vcHRpb25zLnNpZ25hbCA9IGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29udGV4dC5yZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBjb250ZXh0LnJlcXVlc3QsXG4gICAgICAgIGNvbnRleHQub3B0aW9uc1xuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udGV4dC5lcnJvciA9IGVycm9yO1xuICAgICAgaWYgKGNvbnRleHQub3B0aW9ucy5vblJlcXVlc3RFcnJvcikge1xuICAgICAgICBhd2FpdCBjYWxsSG9va3MoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMub25SZXF1ZXN0RXJyb3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCBvbkVycm9yKGNvbnRleHQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoYWJvcnRUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhYm9ydFRpbWVvdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYXNCb2R5ID0gKGNvbnRleHQucmVzcG9uc2UuYm9keSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vdW5qcy9vZmV0Y2gvaXNzdWVzLzMyNFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bmpzL29mZXRjaC9pc3N1ZXMvMjk0XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0pha2VDaGFtcGlvbi9mZXRjaC9pc3N1ZXMvMTQ1NFxuICAgIGNvbnRleHQucmVzcG9uc2UuX2JvZHlJbml0KSAmJiAhbnVsbEJvZHlSZXNwb25zZXMuaGFzKGNvbnRleHQucmVzcG9uc2Uuc3RhdHVzKSAmJiBjb250ZXh0Lm9wdGlvbnMubWV0aG9kICE9PSBcIkhFQURcIjtcbiAgICBpZiAoaGFzQm9keSkge1xuICAgICAgY29uc3QgcmVzcG9uc2VUeXBlID0gKGNvbnRleHQub3B0aW9ucy5wYXJzZVJlc3BvbnNlID8gXCJqc29uXCIgOiBjb250ZXh0Lm9wdGlvbnMucmVzcG9uc2VUeXBlKSB8fCBkZXRlY3RSZXNwb25zZVR5cGUoY29udGV4dC5yZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSB8fCBcIlwiKTtcbiAgICAgIHN3aXRjaCAocmVzcG9uc2VUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY29udGV4dC5yZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgY29uc3QgcGFyc2VGdW5jdGlvbiA9IGNvbnRleHQub3B0aW9ucy5wYXJzZVJlc3BvbnNlIHx8IGRlc3RyO1xuICAgICAgICAgIGNvbnRleHQucmVzcG9uc2UuX2RhdGEgPSBwYXJzZUZ1bmN0aW9uKGRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdHJlYW1cIjoge1xuICAgICAgICAgIGNvbnRleHQucmVzcG9uc2UuX2RhdGEgPSBjb250ZXh0LnJlc3BvbnNlLmJvZHkgfHwgY29udGV4dC5yZXNwb25zZS5fYm9keUluaXQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnRleHQucmVzcG9uc2UuX2RhdGEgPSBhd2FpdCBjb250ZXh0LnJlc3BvbnNlW3Jlc3BvbnNlVHlwZV0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5vcHRpb25zLm9uUmVzcG9uc2UpIHtcbiAgICAgIGF3YWl0IGNhbGxIb29rcyhcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY29udGV4dC5vcHRpb25zLm9uUmVzcG9uc2VcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghY29udGV4dC5vcHRpb25zLmlnbm9yZVJlc3BvbnNlRXJyb3IgJiYgY29udGV4dC5yZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIGNvbnRleHQucmVzcG9uc2Uuc3RhdHVzIDwgNjAwKSB7XG4gICAgICBpZiAoY29udGV4dC5vcHRpb25zLm9uUmVzcG9uc2VFcnJvcikge1xuICAgICAgICBhd2FpdCBjYWxsSG9va3MoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMub25SZXNwb25zZUVycm9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgb25FcnJvcihjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQucmVzcG9uc2U7XG4gIH07XG4gIGNvbnN0ICRmZXRjaCA9IGFzeW5jIGZ1bmN0aW9uICRmZXRjaDIocmVxdWVzdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHIgPSBhd2FpdCAkZmV0Y2hSYXcocmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHIuX2RhdGE7XG4gIH07XG4gICRmZXRjaC5yYXcgPSAkZmV0Y2hSYXc7XG4gICRmZXRjaC5uYXRpdmUgPSAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG4gICRmZXRjaC5jcmVhdGUgPSAoZGVmYXVsdE9wdGlvbnMgPSB7fSwgY3VzdG9tR2xvYmFsT3B0aW9ucyA9IHt9KSA9PiBjcmVhdGVGZXRjaCh7XG4gICAgLi4uZ2xvYmFsT3B0aW9ucyxcbiAgICAuLi5jdXN0b21HbG9iYWxPcHRpb25zLFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAuLi5nbG9iYWxPcHRpb25zLmRlZmF1bHRzLFxuICAgICAgLi4uY3VzdG9tR2xvYmFsT3B0aW9ucy5kZWZhdWx0cyxcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICRmZXRjaDtcbn1cblxuZXhwb3J0IHsgRmV0Y2hFcnJvciBhcyBGLCBjcmVhdGVGZXRjaEVycm9yIGFzIGEsIGNyZWF0ZUZldGNoIGFzIGMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs\n");

/***/ })

};
;